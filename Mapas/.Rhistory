length(curvas_2007)
nrow(curvas_2007[[1]])
# Reestructuramos para poder usar el procedimiento
lon_list <- list()
lat_list <- list()
# Iterar sobre cada curva
for (i in 1:length(curvas_2007)) {
# Convertir lon y lat en matrices, si no lo son ya
lon_list[[i]] <- curvas_2007[[i]]$lon
lat_list[[i]] <- curvas_2007[[i]]$lat
}
# Combinar las listas en dataframes
lon_df <- do.call(rbind, lon_list)
lat_df <- do.call(rbind, lat_list)
# Crear el dataframe estructurado y renombrar las columnas
df_struc <- data.frame(lon_df, lat_df)
colnames(df_struc) <- c(paste0("lon_", 1:ncol(lon_df)), paste0("lat_", 1:ncol(lat_df)))
# Hay que verlo como matriz y ponerlo en formato "double"
df_struc <- as.matrix(df_struc) # Tenemos las 368
storage.mode(df_struc) <- "double"
# Nos quedamos con las curvas más profundas
q_max = which(winter[[anio]]$depth > quantile(winter[[anio]]$depth,0.60)) # 40% más profundo
df_struc <- df_struc[q_max,] # Nos quedan 92
nrow(df_struc)
help(rnorm)
retry_archetypes <- function(df, n_arch, seed_arch, max_iter) {
for (i in 1:max_iter) {
set.seed(seed_arch + i)
tryCatch({
arch <- tryCatch({
# Intento sin ruido
arquetipos_prueba <-archetypes(df_struc, k = n_arquetipos)
}, error = function(e) {
message("Error encountered: ", e$message)
message("Lo hacemos agregando un ruido")
# Intento con ruido
df_struc_noisy <- df_struc + matrix(rnorm(length(df_struc), mean = 0, sd = epsilon), nrow = nrow(df_struc))
arquetipos_prueba <- archetypes(df_struc_noisy, k = n_arquetipos)
})
return(parameters(arch))  # Retorna los arquetipos si es exitoso
}, warning = function(w) {
if (grepl("alphas > maxKappa", w$message)) {
return(NULL)
} else {
return(NULL)
}
}, error = function(e) {
return(NULL)
})
}
return(NULL)  # Return NULL if no successful result after max_iter
}
rm(retry_archetypes)
retry_archetypes <- function(df, n_arch, seed_arch, max_iter, epsilon = 1e-6) {
for (i in 1:max_iter) {
set.seed(seed_arch + i)
# First attempt: try computing archetypes without noise
tryCatch({
arch <- archetypes(data = df, k = n_arch, verbose = FALSE)
return(parameters(arch))  # Return the archetypes if successful
}, error = function(e) {
message("Error encountered without noise: ", e$message)
message("Attempting with added noise...")
# If failed, try adding noise and retry
df_noisy <- df + matrix(rnorm(length(df), mean = 0, sd = epsilon), nrow = nrow(df))
arch <- archetypes(data = df_noisy, k = n_arch, verbose = FALSE)
return(parameters(arch))  # Return the archetypes if successful
})
# If still fails after adding noise, return NULL
message("Failed to compute archetypes after adding noise.")
return(NULL)
}
return(NULL)  # Return NULL if no successful result after max_iter
}
df_struc
df_struc
retry_archetypes(df_struc, n_arch = 6, seed_arch = 123, max_iter = 10, epsilon = 1e-6)
# Definimos un ruido
epsilon <- 1e-6
n_arquetipos <- 6 # Esto puede romper
# Tratamos de hacer archetipos. Si rompe así como viene, vamos a agregar un ruido
arquetipos_prueba <- tryCatch({
# Intento sin ruido
arquetipos_prueba <-archetypes(df_struc, k = n_arquetipos)
}, error = function(e) {
message("Error encountered: ", e$message)
message("Lo hacemos agregando un ruido")
# Intento con ruido
df_struc_noisy <- df_struc + matrix(rnorm(length(df_struc), mean = 0, sd = epsilon), nrow = nrow(df_struc))
arquetipos_prueba <- archetypes(df_struc_noisy, k = n_arquetipos)
})
retry_archetypes <- function(df, n_arch, seed_arch, max_iter, epsilon = 1e-6) {
for (i in 1:max_iter) {
set.seed(seed_arch + i)
# Try without noise first
arch <- tryCatch({
archetypes(data = df, k = n_arch, verbose = FALSE)
}, error = function(e) {
return(NULL)  # Return NULL if there's an error
})
if (!is.null(arch)) {
return(parameters(arch))  # Return the archetypes if successful
}
# If it failed, try adding noise
message("Error encountered, trying with added noise...")
df_noisy <- df + matrix(rnorm(length(df), mean = 0, sd = epsilon), nrow = nrow(df))
arch <- tryCatch({
archetypes(data = df_noisy, k = n_arch, verbose = FALSE)
}, error = function(e) {
return(NULL)  # Return NULL if there's an error
})
if (!is.null(arch)) {
return(parameters(arch))  # Return the archetypes if successful
}
# If both attempts fail, continue to the next iteration
message("Failed to compute archetypes after adding noise.")
}
return(NULL)  # Return NULL if no successful result after max_iter
}
retry_archetypes(df_struc, n_arch = 6, seed_arch = 123, max_iter = 10, epsilon = 1e-6)
# Definimos un ruido
epsilon <- 1e-6
n_arquetipos <- 6 # Esto puede romper
# Tratamos de hacer archetipos. Si rompe así como viene, vamos a agregar un ruido
arquetipos_prueba <- tryCatch({
# Intento sin ruido
arquetipos_prueba <-archetypes(df_struc, k = n_arquetipos)
}, error = function(e) {
message("Error encountered: ", e$message)
message("Lo hacemos agregando un ruido")
# Intento con ruido
df_struc_noisy <- df_struc + matrix(rnorm(length(df_struc), mean = 0, sd = epsilon), nrow = nrow(df_struc))
arquetipos_prueba <- archetypes(df_struc_noisy, k = n_arquetipos)
})
arquetipos_prueba
arquetipos_prueba$archetypes
arquetipos_prueba_v1  = retry_archetypes(df_struc, n_arch = 6, seed_arch = 123, max_iter = 10, epsilon = 1e-6)
arquetipos_prueba_v2 = arquetipos_prueba$archetypes
arquetipos_prueba_v1
arquetipos_prueba_v2
rm(arquetipos_prueba_v1)
rm(arquetipos_prueba_v2)
rm(arquetipos_prueba_v1)
# Hacemos un loop de arquetipos para, en caso de que a pesar de las iteraciones y el ruido, no encuentre la cantidad deseada,
# y entonces baje a buscar una cantidad una unidad menor.
n_arquetipos
for (k in 1:n_arquetipos) {
arch <- retry_archetypes(df_struc, n_arch = 6, seed_arch = 123, max_iter = 10, epsilon = 1e-6)
if (is.null(arch)) {
message("Failed to compute archetypes for cluster ", k, " with n_arch = ", n_arch)
# Probamos de bajar la cantidad de arquetipos y calcular de nuevo
arch <- retry_archetypes(df_cluster, n_arch - 1, seed_arch, max_iter)
if (is.null(arch)) {
stop("Failed to compute archetypes with reduced number as well.")
}
}
arquetipos_prueba <- arch
}
arquetipos_prueba
arquetipos_prueba
# Volvemos a armar los arquetipos como trayectorias
arquetipos <- arquetipos_prueba
trayectorias_arquetipicas <- replicate(n_arquetipos, list(), simplify = FALSE)
# Suponemos que ambas tienen tantas longitudes como latitudes, lo cual siempre va a ser cierto en estos casos
for(cant in 1:n_arquetipos) {
trayectorias_arquetipicas[[cant]] <- arquetipos[cant, ]
}
for (i in 1:n_arquetipos) {
# Extraemos las listas
current_list <- trayectorias_arquetipicas[[i]]
# Obtenemos longitud de las mismas
n <- length(current_list)
# Partimos en dos la cantidad de columnas
lon_values <- as.numeric(current_list[1:(n/2)])
lat_values <- as.numeric(current_list[(n/2 + 1):n])
# Creamos las trayectorias como las teníamos inicialmente
trayectorias_arquetipicas[[i]] <- data.frame(lon = round(lon_values,3), lat = round(lat_values,3)) # Esto es para que nos quede en la misma precisión que lo que venía en el .RDS
}
# Esto nos queda como lo que levantábamos inicialmente del .RDS
trayectorias_arquetipicas
# ANTES DE CLUSTERIZAR VAMOS A NECESITAR ARMAR LA MATRIZ DE DISTANCIAS DE FRÉCHET
class(trayectorias_arquetipicas)
length(trayectorias_arquetipicas)
# Inicializamos la matriz de distancias de Fréchet vacía. ACA TUVIMOS QUE MODIFICAR LA DISTANCIA DE FRÉCHET
frechet_dist_matrix <- matrix(NA, n_arquetipos, n_arquetipos)
tic()
# Vamos a hacer las distancias, pero únicamente las que están debajo de la diagonal
for (j in 2:n_arquetipos) {
for (i in 1:(j - 1)) {
# Hacemos los pares de trayectorias
traj_i <- as.matrix(trayectorias_arquetipicas[[i]])
traj_j <- as.matrix(trayectorias_arquetipicas[[j]])
# Computamos las distancias
dist_ij <- frechet$frechet_dist(traj_i, traj_j)
frechet_dist_matrix[j, i] <- dist_ij
}
}
toc()
frechet <- import("similaritymeasures")
# Inicializamos la matriz de distancias de Fréchet vacía. ACA TUVIMOS QUE MODIFICAR LA DISTANCIA DE FRÉCHET
frechet_dist_matrix <- matrix(NA, n_arquetipos, n_arquetipos)
tic()
# Vamos a hacer las distancias, pero únicamente las que están debajo de la diagonal
for (j in 2:n_arquetipos) {
for (i in 1:(j - 1)) {
# Hacemos los pares de trayectorias
traj_i <- as.matrix(trayectorias_arquetipicas[[i]])
traj_j <- as.matrix(trayectorias_arquetipicas[[j]])
# Computamos las distancias
dist_ij <- frechet$frechet_dist(traj_i, traj_j)
frechet_dist_matrix[j, i] <- dist_ij
}
}
toc()
# Lo convertimos en distancia
frechet_dist_matrix[is.na(frechet_dist_matrix)] <- 0
frechet_dist_matrix <- as.dist(frechet_dist_matrix)
frechet_dist_matrix
dendograma = hclust(frechet_dist_matrix, method = "ward.D2", members = NULL)
plot(dendograma, main = "Dendrograma de ward.D2 sobre la matriz de distancia de Fréchet", hang = -1)
# Cortamos el dendograma para hacer los clusters
clusters <- cutree(dendograma, k = 2)
print(clusters)
rect.hclust(dendograma, k = 2, border = "red")
# Armamos la proyección con las referencias para el mapa
wm <- map_data("world")
byers_map = ggplot() +
geom_polygon(
data = wm, aes(x = long, y = lat, group = group),
fill = "white", colour = "black", alpha = 0.8, size=0.3
) +
scale_y_continuous(
limits = c(-90, -30), breaks = seq(-45, -90, by = -10),
labels = NULL, expand = c(0, 0)
) +
scale_x_continuous(breaks = NULL, expand = c(0, 0)) +
theme(panel.background = element_rect(fill = "white"),
axis.ticks=element_blank()) +
coord_map("ortho", orientation = c(-90, -60, 0), xlim=c(-180,-10), ylim=c(-30,-90)) +
labs(x = NULL, y = NULL)
byers_map
length(winter) # Esto es todo invierno, que son 12 años
length(curvas_2007) # Esto es el caso que tomamos, que tiene 368 trayectorias
# Prueba Manual
titulo_w = paste0("Probamos - para borrar")
byers_map_w = byers_map + ggtitle(titulo_w)
n_arc = length(trayectorias_arquetipicas)
clust_arc = clusters # Van a ser los colores de los clusters del arquetipo
clust_arc
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[1]], aes(x=lon, y=lat), color="darkblue", alpha = 0.5)
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[2]], aes(x=lon, y=lat), color="darkblue", alpha = 0.5)
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[3]], aes(x=lon, y=lat), color="darkblue", alpha = 0.5)
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[4]], aes(x=lon, y=lat), color="darkblue", alpha = 0.5)
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[5]], aes(x=lon, y=lat), color="darkblue", alpha = 0.5)
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[6]], aes(x=lon, y=lat), color="darkred", alpha = 0.5)
byers_map_w = byers_map_w + theme(plot.title = element_text(size = 30, face = "bold"))
print(byers_map_w)
# En particular, hacemos primero un ejercicio con el invierno de 2007
anio = 3 # 3 es el 2007, 6 es el 2010, 7 es 2011
curvas_2007 = winter[[anio]]$curves
length(curvas_2007) # Son 368 curvas
nrow(curvas_2007[[1]]) # Para cada curva tenemos 121 ubicaciones
# Reestructuramos para poder usar el procedimiento
lon_list <- list()
lat_list <- list()
# Iterar sobre cada curva
for (i in 1:length(curvas_2007)) {
# Convertir lon y lat en matrices, si no lo son ya
lon_list[[i]] <- curvas_2007[[i]]$lon
lat_list[[i]] <- curvas_2007[[i]]$lat
}
# Combinar las listas en dataframes
lon_df <- do.call(rbind, lon_list)
lat_df <- do.call(rbind, lat_list)
# Crear el dataframe estructurado y renombrar las columnas
df_struc <- data.frame(lon_df, lat_df)
colnames(df_struc) <- c(paste0("lon_", 1:ncol(lon_df)), paste0("lat_", 1:ncol(lat_df)))
# Hay que verlo como matriz y ponerlo en formato "double"
df_struc <- as.matrix(df_struc) # Tenemos las 368
storage.mode(df_struc) <- "double"
# Nos quedamos con las curvas más profundas
q_max = which(winter[[anio]]$depth > quantile(winter[[anio]]$depth,0.60)) # 40% más profundo
df_struc <- df_struc[q_max,]
nrow(df_struc) # Nos quedan 147 curvas profundas
retry_archetypes <- function(df, n_arch, seed_arch, max_iter, epsilon = 1e-6) {
for (i in 1:max_iter) {
set.seed(seed_arch + i)
# Probamos primero sin ruido
arch <- tryCatch({
archetypes(data = df, k = n_arch, verbose = FALSE)
}, error = function(e) {
return(NULL)  # NULL si hay un error
})
if (!is.null(arch)) {
return(parameters(arch))  # Trae los arquetipos si es exitoso
}
# Si falla, agrega un ruido
message("Error encountered, trying with added noise...")
df_noisy <- df + matrix(rnorm(length(df), mean = 0, sd = epsilon), nrow = nrow(df))
arch <- tryCatch({
archetypes(data = df_noisy, k = n_arch, verbose = FALSE)
}, error = function(e) {
return(NULL)  # NULL si hay un error
})
if (!is.null(arch)) {
return(parameters(arch))  # Trae los arquetipos si es exitoso
}
# Si acá falla, prueba la siguiente iteración
message("Failed to compute archetypes after adding noise.")
}
return(NULL)  # Return NULL if no successful result after max_iter
}
for (k in 1:n_arquetipos) {
arch <- retry_archetypes(df_struc, n_arch = 6, seed_arch = 123, max_iter = 10, epsilon = 1e-6)
if (is.null(arch)) {
message("Failed to compute archetypes for cluster ", k, " with n_arch = ", n_arch)
# Probamos de bajar la cantidad de arquetipos y calcular de nuevo
arch <- retry_archetypes(df_cluster, n_arch - 1, seed_arch, max_iter)
if (is.null(arch)) {
stop("Failed to compute archetypes with reduced number as well.")
}
}
arquetipos_prueba <- arch
}
# Volvemos a armar los arquetipos como trayectorias
arquetipos <- arquetipos_prueba
trayectorias_arquetipicas <- replicate(n_arquetipos, list(), simplify = FALSE)
# Suponemos que ambas tienen tantas longitudes como latitudes, lo cual siempre va a ser cierto en estos casos
for(cant in 1:n_arquetipos) {
trayectorias_arquetipicas[[cant]] <- arquetipos[cant, ]
}
for (i in 1:n_arquetipos) {
# Extraemos las listas
current_list <- trayectorias_arquetipicas[[i]]
# Obtenemos longitud de las mismas
n <- length(current_list)
# Partimos en dos la cantidad de columnas
lon_values <- as.numeric(current_list[1:(n/2)])
lat_values <- as.numeric(current_list[(n/2 + 1):n])
# Creamos las trayectorias como las teníamos inicialmente
trayectorias_arquetipicas[[i]] <- data.frame(lon = round(lon_values,3), lat = round(lat_values,3)) # Esto es para que nos quede en la misma precisión que lo que venía en el .RDS
}
# Esto nos queda como lo que levantábamos inicialmente del .RDS
trayectorias_arquetipicas
# ANTES DE CLUSTERIZAR VAMOS A NECESITAR ARMAR LA MATRIZ DE DISTANCIAS DE FRÉCHET
class(trayectorias_arquetipicas)
length(trayectorias_arquetipicas)
# Inicializamos la matriz de distancias de Fréchet vacía. ACA TUVIMOS QUE MODIFICAR LA DISTANCIA DE FRÉCHET
frechet_dist_matrix <- matrix(NA, n_arquetipos, n_arquetipos)
tic()
# Vamos a hacer las distancias, pero únicamente las que están debajo de la diagonal
for (j in 2:n_arquetipos) {
for (i in 1:(j - 1)) {
# Hacemos los pares de trayectorias
traj_i <- as.matrix(trayectorias_arquetipicas[[i]])
traj_j <- as.matrix(trayectorias_arquetipicas[[j]])
# Computamos las distancias
dist_ij <- frechet$frechet_dist(traj_i, traj_j)
frechet_dist_matrix[j, i] <- dist_ij
}
}
toc()
# Lo convertimos en distancia
frechet_dist_matrix[is.na(frechet_dist_matrix)] <- 0
frechet_dist_matrix <- as.dist(frechet_dist_matrix)
dendograma = hclust(frechet_dist_matrix, method = "ward.D2", members = NULL)
plot(dendograma, main = "Dendrograma de ward.D2 sobre la matriz de distancia de Fréchet", hang = -1)
# Cortamos el dendograma para hacer los clusters
clusters <- cutree(dendograma, k = 2)
print(clusters)
rect.hclust(dendograma, k = 2, border = "red")
# Armamos la proyección con las referencias para el mapa
wm <- map_data("world")
byers_map = ggplot() +
geom_polygon(
data = wm, aes(x = long, y = lat, group = group),
fill = "white", colour = "black", alpha = 0.8, size=0.3
) +
scale_y_continuous(
limits = c(-90, -30), breaks = seq(-45, -90, by = -10),
labels = NULL, expand = c(0, 0)
) +
scale_x_continuous(breaks = NULL, expand = c(0, 0)) +
theme(panel.background = element_rect(fill = "white"),
axis.ticks=element_blank()) +
coord_map("ortho", orientation = c(-90, -60, 0), xlim=c(-180,-10), ylim=c(-30,-90)) +
labs(x = NULL, y = NULL)
byers_map
length(winter) # Esto es todo invierno, que son 12 años
length(curvas_2007) # Esto es el caso que tomamos, que tiene 368 trayectorias
# Prueba Manual
titulo_w = paste0("Probamos - para borrar")
byers_map_w = byers_map + ggtitle(titulo_w)
n_arc = length(trayectorias_arquetipicas)
clust_arc = clusters # Van a ser los colores de los clusters del arquetipo
clust_arc
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[1]], aes(x=lon, y=lat), color="darkblue", alpha = 0.5)
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[2]], aes(x=lon, y=lat), color="darkred", alpha = 0.5)
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[3]], aes(x=lon, y=lat), color="darkblue", alpha = 0.5)
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[4]], aes(x=lon, y=lat), color="darkblue", alpha = 0.5)
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[5]], aes(x=lon, y=lat), color="darkblue", alpha = 0.5)
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[6]], aes(x=lon, y=lat), color="darkblue", alpha = 0.5)
byers_map_w = byers_map_w + theme(plot.title = element_text(size = 30, face = "bold"))
print(byers_map_w)
# Ploteamos
mapas_path_deep <- Sys.getenv("MAPAS_PATH") # Esto está definido en DATA_PATH
mapas_path_deep
# Ploteamos
mapas_path_deep <- Sys.getenv("MAPAS_PATH") # Esto está definido en DATA_PATH
mapas_path_deep
# Levantamos los datos. Usamos "winter_traj_ver2.rds". Esto tiene la data de "Byers_2005_2016" con las profundidades ya computadas.
load_dot_env(file = "config.env")
# Ploteamos
mapas_path_deep <- Sys.getenv("MAPAS_PATH") # Esto está definido en DATA_PATH
mapas_path_deep
mapas_path_deep <- Sys.getenv("MAPAS_PATH") # Esto está definido en DATA_PATH
# Esto es para el plot de los datos totales, los datos más profundos y los arquetipos
tic()
for (k in anio:anio) { # Es 1:length(winter) en realidad, e hicimos 1:1 para que haga el año 2005
titulo_w = paste0("Prueba de arquetipos al 40% - ", 2005+k-1)
byers_map_w = byers_map + ggtitle(titulo_w)
q_max = which(winter[[k]]$depth > quantile(winter[[k]]$depth,0.60)) # el n% más profundo
q_resto = which(winter[[k]]$depth <= quantile(winter[[k]]$depth,0.60)) # El resto
n_arc = length(trayectorias_arquetipicas)
clust_arc = clusters # Van a ser los colores de los clusters del arquetipo
# Curvas menos profundas
for (j in q_resto)
byers_map_w = byers_map_w + geom_path(data = winter[[k]]$curves[[j]], aes(x=lon, y=lat), color="lightgrey", alpha = 0.5)
# Curvas más profundas
for (i in q_max)
byers_map_w = byers_map_w + geom_path(data = winter[[k]]$curves[[i]], aes(x=lon, y=lat), color = "darkred", alpha = 0.5)
# Esto es para el plot con todos los arquetipos con el mismo color
for (i in 1:n_arc)
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[i]], aes(x=lon, y=lat), color="darkblue", alpha = 0.5)
byers_map_w = byers_map_w + theme(plot.title = element_text(size = 30, face = "bold"))
setwd(mapas_path_deep)
png(filename=paste0(2005+k-1,"_depth.png"), width=800, height=800)
print(byers_map_w)
dev.off()
}
toc()
# Esto es para ver los colores de los clusters del arquetipo
tic()
for (k in anio:anio) { # Es 1:length(winter) en realidad, e hicimos 1:1 para que haga el año 2005
titulo_w = paste0("Prueba de arquetipos al 40% - ", 2005+k-1)
byers_map_w = byers_map + ggtitle(titulo_w)
q_max = which(winter[[k]]$depth > quantile(winter[[k]]$depth,0.60)) # el n% más profundo
q_resto = which(winter[[k]]$depth <= quantile(winter[[k]]$depth,0.60)) # El resto
n_arc = length(trayectorias_arquetipicas)
clust_arc = clusters # Van a ser los colores de los clusters del arquetipo
# Curvas menos profundas
for (j in q_resto)
byers_map_w = byers_map_w + geom_path(data = winter[[k]]$curves[[j]], aes(x=lon, y=lat), color="lightgrey", alpha = 0.5)
# Esto es para tener a cada arquetipo con los colores del cluster
for (i in 1:n_arc)
byers_map_w = byers_map_w + geom_path(data = trayectorias_arquetipicas[[i]], aes(x=lon, y=lat), color = clust_arc[i] , alpha = 0.5)
byers_map_w = byers_map_w + theme(plot.title = element_text(size = 30, face = "bold"))
setwd(mapas_path_deep)
png(filename=paste0(2005+k-1,"_arc_para_cluster.png"), width=800, height=800)
print(byers_map_w)
dev.off()
}
toc()
# Ahora debiéramos computarle la distancia de Fréchet a todas las curvas, y clusterizarlas en función de a cual se encuentran
# más cerca
gc()
tic()
# Inicializamos el vector donde vamos a guardar el arquetipo más cercano a la curva
closest_archetype <- numeric(length(winter[[anio]]$curves))
clust_archetypes <- clusters # Esto viene de arriba, de hacer un cluster jerárquico sobre la matriz de distancia de Fréchet
# Hacemos el Loop para todas las trayectorias del año
for (j in 1:length(winter[[anio]]$curves)) {
# Extraemos la observación
current_curve <- as.matrix(winter[[anio]]$curves[[j]])
# Hacemos la listas a donde va a ir cada distancia respecto a cada arquetipo vis-à-vis
distances <- numeric(length(trayectorias_arquetipicas))
# Loopeamos a través de todos las trayectorias arquetipo que tengamos previamente calculadas
for (i in 1:length(trayectorias_arquetipicas)) {
# Exctraemos la i-ésimo trayectoria arquetipo
archetype_curve <- as.matrix(trayectorias_arquetipicas[[i]])
# Computamos la distancia de Fréchet
# distances[i] <- Frechet(current_curve, archetype_curve)[[1]] # Esto era con la implementación vieja
distances[i] <- frechet$frechet_dist(current_curve, archetype_curve)
}
# Esto era ANTES
# # Asignamos el arquetipo más cercano para cada curva
# closest_archetype[j] <- which.min(distances)
# Esto es AHORA
# Buscamos el índica del más cercano
# distances[distances < 0] <- NA # Esto lo pusimos de barrera en "Prueba interna.R", pero porque usábamos la librería de R
closest_archetype_index <- which.min(distances)
# Asignamos su cluster
closest_archetype[j] <- clust_archetypes[closest_archetype_index]
}
toc()
# CON LA NUEVA IMPLEMENTACIÓN DE PYTHON TARDÓ 21.908 SEGUNDOS!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# Ploteamos
tic()
for (k in anio:anio) { # Es 1:length(winter) en realidad, e hicimos 1:1 para que haga el año 2005
byers_map_w = byers_map
titulo_w = paste0("Prueba de clusters al 40% - ", 2005+k-1)
byers_map_w = byers_map_w + ggtitle(titulo_w)
for (i in 1:length(winter[[k]]$curves))
byers_map_w = byers_map_w + geom_path(data=winter[[k]]$curves[[i]], aes(x = lon, y = lat, ), color = as.factor(closest_archetype[i]),  alpha=0.5)
byers_map_w = byers_map_w + theme(plot.title = element_text(size = 30, face = "bold"))
setwd(mapas_path_deep)
png(filename=paste0(2005+k-1,"_cluster.png"), width=800, height=800)
print(byers_map_w)
dev.off()
}
toc()
